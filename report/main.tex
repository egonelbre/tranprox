% document type
\documentclass [12pt]{article} % oneside

% fixes
\usepackage{fixltx2e} % LaTeX patches, \textsubscript
\usepackage{cmap} % fix search and cut-and-paste in PDF

% language
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% usability
\usepackage {float}

% formatting
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{setspace}
\usepackage{hyperref}

\usepackage{fancyvrb}
\usepackage{mdwlist}
\usepackage{float,caption}

\usepackage{graphicx}
\usepackage{ifpdf}
\usepackage{listings, textcomp, color, xcolor, caption}

\title{Approximating discontinous functions}

\author{
    Egon Elbre, Olga Agen \\
        Department of Computer Science \\
    University of Tartu\\
    Tartu\\
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Calculating discontinous functions can be difficult and computationally
expensive. By combining using approximation functions we can lower 
the computational expensiveness at the cost of errors.
Defining good approximation function can be a hard to get right. 
However, defining an approximation that works for some value can 
be simpler. We show how combining several simple approximations 
can give us a better approximation and reduce computational requirements.
\end{abstract}

\section{Introduction}

\paragraph{Outline}

\section{Theory}

\newcommand{\Real}{\mathbb{R}}
\newcommand{\defas}{ := }
\newcommand{\err}[1]{\varepsilon_{#1}}

We are trying to approximate a function $f$:

$$f : X \mapsto \Real$$

Although we explain the idea in $\Real$ set, the results also apply to 
any set that has transitive relation $<$ and $+-$ operation (TODO: find the correct algebraic structure). 
Using $<$ we can define $\min$ and $\max$ for that set.

$$ \min(x,y) \defas \begin{cases}
    x & \text{if $x \leq y$}, \\
    y & \text{otherwise}.
\end{cases}
$$

$$
\max(x,y) \defas \begin{cases}
    y & \text{if $x \leq y$}, \\
    x & \text{otherwise}.
\end{cases}
$$

X can be any set.

\subsection{Exact approximation}

Let's assume we are interested in range $R \subseteq X$. Let's assume we 
have functions $\alpha$ and $\beta$ such that

\begin{align*}
    \alpha(x) &\leq f(x), \forall x \in R \\
    \beta(x)  &\leq f(x), \forall x \in R 
\end{align*}

Now we can define $\epsilon$ function.

\begin{align*}
    \alpha(x) &= f(x) + \err\alpha, \err\alpha \geq 0 \\
    \beta(x)  &= f(x) + \err\beta, \err\alpha \geq 0
\end{align*}

It is trivial to derive function $\gamma$ where $\err\gamma$ is smaller 
than $\err\alpha$ and $\err\beta$.

\begin{align*}
    \gamma(x)   &= max(\alpha(x), \beta(x)) \\
                &= max(f(x) - \err\alpha(x), f(x) - \err\beta(x)) \\
                &= f(x) - min(\err\alpha(x), \err\beta(x)).
\end{align*}

This also gives us a usefulness requirement for $\alpha$ and $\beta$:

\begin{align*}
    \exists x \in R, ~ &\alpha(x) < \beta(x) \\
    \exists x \in R, ~ &\beta(x) < \alpha(x)
\end{align*}

This means that function $\alpha$ and $\beta$ must be complementary.
For some inputs one should give better approximations than the other.

\subsection{Probablisitic approximation}

Having such hard boundary severly restricts the possible functions we can
use. If we allow some mistake in the boundary we can get better precision,
but we won't know to which side we will make errors.

Depending of our use case it may be acceptable.

\section{Distance approximation}

The same idea can be used in distance measures.

$$
  f(x,y) = max(g(x,y), h(x,y))
$$

Since most distance measures are required to calculate between multiple
elements we can first do a transformation into a metric space and then
use the same prinicple to extract the distance.

$$
  f(x,y) = max( dist_1(t_1(x), t_1(y)), dist_2(t_2(x), t_2(y)) )
$$

This way we can reuse computation of $t_1$ or even do additional operations on it.
For example it can allow us to do range querys.

$$
  query(x,R) = \{ y | dist_1(t_1(x), t_1(y)) <= R \} \cap \{ y | dist_2(t_2(x), t_2(y)) <= R \}
$$

If our distance function is simple, such as Manhattan or Euclidian, we can 
use already existing range query algorithms and data structures.

\section{Example: Levenshtein on Nucleotide Sequences}

We expect that the reader is already familiar with Levenshtein algorithm and
ideas behind Fourier and Wavelet transformations. Refer to better source.

As the basis we use hamming, smoothing, fourier, haar transformation. 

\subsection{Using}

\subsection{Results}

\section{Conclusions}

The design of approximationing functions becomes much simpler when we restrict the
space where they work correctly.

The results show that this idea could be useful, although the extent of usability
needs further analysis.

\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{bibliography}

\end{document}